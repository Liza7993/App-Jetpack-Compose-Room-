Під час перегляду курсу «Збереження даних за допомогою Room» я навчилася створювати просту інвентаризаційну систему на Android із використанням Jetpack Compose та MVVM-архітектури, зрозуміла, як працювати зі стійкими даними, створювати базу SQLite за допомогою Room, додавати, редагувати та видаляти записи, а також керувати навігацією між екранами за допомогою NavHost; курс допоміг мені ознайомитися з основами Compose та роботою з ViewModel, показав, як використовувати корутини для виконання фонових задач, і що для роботи з базою даних важливо мати базові знання SQL та вміти організовувати екрани для перегляду списку товарів, додавання нового товару і редагування існуючих записів; особливу увагу у курсі приділено Room, який спрощує створення таблиць, запитів і взаємодію з базою даних, я переглянула приклади створення Entity-класу Item, який представляє таблицю items і містить поля id, name, price та quantity, дізналася, що Room автоматично генерує первинний ключ для кожного нового запису; я навчилася працювати з DAO — інтерфейсом для взаємодії з даними, де оголошені методи вставки, оновлення, отримання та видалення товарів, зрозуміла, що всі операції з базою виконуються у фонових потоках за допомогою ключового слова suspend, а Room гарантує перевірку SQL-запитів на етапі компіляції; також я зрозуміла, як організувати взаємодію бази даних із ViewModel та репозиторієм, переглянувши приклади екранів HomeScreen та ItemEntryScreen, навчилася додавати нові товари, переглядати існуючі записи та переходити до їх редагування, а курс показав, як налаштувати навігацію між екранами через NavHost; у підсумку після перегляду курсу я навчилася створювати застосунок, який зберігає дані локально у SQLite і забезпечує їхнє редагування та видалення, і завдяки Room усі дані залишаються збереженими навіть після перезапуску застосунку.

├── data
│   ├── AppContainer.kt             # Контейнер для ініціалізації репозиторіїв
│   ├── InventoryDatabase.kt        # Клас бази даних Room

│   ├── Item.kt                     # Сутність Item з анотацією @Entity
│   ├── ItemDao.kt                  # DAO для роботи з таблицею Item
│   ├── ItemsRepository.kt          # Репозиторій для роботи з Item
│   └── OfflineItemsRepository.kt   # Репозиторій для офлайн режиму
├── ui
│   ├── home
│   │   ├── HomeScreen.kt           # Головний екран зі списком товарів
│   │   └── HomeViewModel.kt        # ViewModel для головного екрану
│   ├── item
│   │   ├── ItemDetailsScreen.kt    # Екран з деталями товару
│   │   ├── ItemDetailsViewModel.kt # ViewModel для деталей товару
│   │   ├── ItemEditScreen.kt       # Екран редагування товару
│   │   ├── ItemEditViewModel.kt    # ViewModel для редагування
│   │   ├── ItemEntryScreen.kt      # Екран додавання нового товару
│   │   └── ItemEntryViewModel.kt   # ViewModel для додавання
│   └── navigation
│       └── InventoryNavGraph.kt    # Навігація між екранами
│   └── theme
│       └── ...                     # Теми та стилі
├── AppViewModelProvider.kt          # Провайдер для ViewModel
├── InventoryApp.kt                  # Головний Composable додатка
├── InventoryApplication.kt          # Клас Application
└── MainActivity.kt                  # Activity запуску додатка


Використання бази даних

У проекті використовується Room як шар абстракції над SQLite для збереження даних про товари.

- InventoryDatabase 
  Основний клас бази даних з singleton-паттерном для отримання єдиного екземпляру.

- Item (Entity)
    - Клас позначений як `@Entity`.
    - Властивості: `id`, `name`, `price`, `quantity`.
    - Відповідає таблиці `items` у базі даних.

- ItemDao (Data Access Object)
  Інтерфейс `ItemDao` містить функції для роботи з таблицею (виконує SQL-запити):
    - `@Insert` — додавання нового товару
    - `@Update` — оновлення товару
    - `@Delete` — видалення товару
    - `@Query` — отримання одного або всіх товарів

- ItemsRepository / OfflineItemsRepository
    - Використовують DAO для роботи з базою даних.
    - Забезпечують чистий інтерфейс для ViewModel.

- ViewModel
    - Призначення: керує даними для UI та зберігає стан екрану.
    - Основне завдання: отримувати дані з репозиторію (`ItemsRepository`), обробляти їх і передавати у UI.
    - Особливості:
        - Не містить логіки відображення — тільки дані і стан.
        - Зберігає стан навіть при перевороті екрану або зміні конфігурації.
        - Використовує StateFlow для спостереження за змінами даних.


- UI (User Interface)
    - Призначення: відповідає за відображення даних та взаємодію з користувачем.
    - Основне завдання: показувати дані, які надає ViewModel, і передавати події користувача назад у ViewModel (наприклад, клік на товар, додавання або видалення).
    - Особливості:
        - Не працює без ViewModel — отримує дані лише через неї.
        - Використовує Jetpack Compose для побудови екрану.
        - Динамічно оновлює відображення при зміні даних у ViewModel через `collectAsState()`.
